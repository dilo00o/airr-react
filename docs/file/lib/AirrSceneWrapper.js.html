<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/AirrSceneWrapper.js | airr-react</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Reusable React components for building Single Page Apps."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="airr-react"><meta property="twitter:description" content="Reusable React components for building Single Page Apps."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/rafal-r/airr-react"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrMayer.js~AirrMayer.html">AirrMayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrScene.js~AirrScene.html">AirrScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrSceneWrapper.js~AirrSceneWrapper.html">AirrSceneWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrSidepanel.js~AirrSidepanel.html">AirrSidepanel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrView.js~AirrView.html">AirrView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrViewWrapper.js~AirrViewWrapper.html">AirrViewWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-AirrFX">AirrFX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Helpers">Helpers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-isMobileDevice">isMobileDevice</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-supportPassive">supportPassive</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/AirrSceneWrapper.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import React from &quot;react&quot;;
import AirrFX from &quot;./AirrFX&quot;;
import AirrScene from &quot;./AirrScene&quot;;
import AirrViewWrapper from &quot;./AirrViewWrapper&quot;;
import update from &quot;immutability-helper&quot;;
import PropTypes from &quot;prop-types&quot;;

export default class AirrSceneWrapper extends AirrViewWrapper {
    /**
     * Object that keep information about views configuraion objects.
     * Every key in this object describes another view.
     * That configuration later will be used to create new view and add it to state views array.
     * Used by ::getFreshViewConfig to deliver new view config.
     * This approach is mainly used in crucial components&apos;s ::changeView method.
     */
    viewsConfig = PropTypes.shape({
        /**
         * Simple view configuraion which can be found by key which is also it&apos;s name.
         */
        &quot;foo-view-name&quot;: {
            /**
             * View type
             */
            type: AirrViewWrapper,
            /**
             * View props
             */
            props: {
                name: &quot;foo-view-name&quot;,
                bar: &quot;baz&quot;,
                factor: 3
            },
            /**
             * Props to modify Scene
             */
            sceneProps: {
                navbar: 1,
                backbutton: true
            }
        },
        /**
         * Common view configutaion that has nameGenerator property that is function
         * used to create another view name propperty.
         */
        &quot;common-view-*&quot;: {
            /**
             * View type
             */
            type: AirrViewWrapper,
            /**
             * View props
             */
            props: {
                name: null,
                baz: &quot;yoo&quot;
            },
            /**
             * Props to modify Scene
             */
            sceneProps: {
                navbar: 0
            },
            /**
             * Function to generate next view name.
             * Gets current state views list as argument.
             */
            nameGenerator: views =&gt; {
                return &quot;common-view-*&quot;.replace(&quot;*&quot;, views.length + 1);
            }
        }
    });

    /**
     * Instantiated views Components refferences
     */
    refsCOMPViews = {};
    /**
     * Instantiated mayers Components refferences
     */
    refsCOMPMayers = {};
    /**
     * Instantiated sidepanel Component refference
     */
    refCOMPSidepanel = React.createRef();
    /**
     * Refference to DOM element of container&apos;s div (first child of most outer element)
     */
    refDOMContainer = React.createRef();
    /**
     * Refference to DOM element of navbar&apos;s div
     */
    refDOMNavbar = React.createRef();

    constructor(props) {
        super(props);

        this.state = {
            name: props.name,
            active: props.active,
            navbar: props.navbar,
            navbarHeight: props.navbarHeight,
            navbarMenu: props.navbarMenu,
            navbarClass: props.navbarClass,
            backButton: props.backButton,
            backButtonOnFirstView: props.backButtonOnFirstView,
            activeViewName: props.activeViewName,
            animation: props.animation,
            views: props.views,
            sidepanel: props.sidepanel,
            GUIDisabled: props.GUIDisabled,
            GUIDisableCover: props.GUIDisableCover,
            mayers: props.mayers,
            children: props.children,
            animationTime: props.animationTime,
            handleBackBehaviourOnFirstView:
                props.handleBackBehaviourOnFirstView,
            viewsAnimationEndCallback: props.viewsAnimationEndCallback,
            handleBackButton: props.handleBackButton,
            stackMode: props.stackMode
        };
    }

    /**
     * Creates new view config base on configuration in `viewsConfig` variable.
     * When `viewNameGenerator` in present base configuration it will use to create new view name property.
     * This feature is handy when you want to easly create next views based upon generic view configuration.
     *
     * @param {string} viewName Name of the configuraion key in `this.viewsConfig` object
     * @param {object} props Additional prop to be merged with base config
     */
    getFreshViewConfig(viewName, props = {}) {
        if (viewName in this.viewsConfig) {
            const config = Object.assign({}, this.viewsConfig[viewName]);
            const viewNameGenerator = this.viewsConfig[viewName].nameGenerator;

            return update(this.viewsConfig[viewName], {
                props: {
                    $set: {
                        ...Object.assign({}, config.props),
                        ...Object.assign({}, props),
                        name:
                            viewNameGenerator &amp;&amp;
                            typeof viewNameGenerator === &quot;function&quot;
                                ? viewNameGenerator(this.state.views)
                                : viewName
                    }
                }
            });
        } else {
            throw new Error(
                `Passed view name &apos;${viewName}&apos; is not present in viewsConfig.`
            );
        }
    }

    /**
     * Array of views names to stay in `this.state.views` array when animation of views finishes.
     * Used in `::viewsAnimationEndCallback` default method to filter views when needed.
     * If you populate names in this array the filter feature will be active by default
     * unless you overwrite `::viewsAnimationEndCallback` method in descendant class.
     */
    viewsNamesToStayList = [];
    viewsAnimationEndCallback = () =&gt; {
        /**
         * If instance variable `viewsNamesToStayList` is set
         * then we filter views array to leave only those with names
         * present in `viewsNamesToStayList` list.
         */
        if (
            Array.isArray(this.viewsNamesToStayList) &amp;&amp;
            this.viewsNamesToStayList.length
        ) {
            this.viewsNamesToStayList.push(this.state.activeViewName);
            this.__filterViews(this.viewsNamesToStayList).then(() =&gt; {
                this.viewsNamesToStayList = [];
            });
        }
    };

    /**
     * Removes views that are not contained by name in array
     * @param {array} viewsNameList List of views names that will stay in state
     * @returns {Promise} Will be resolved on succesful state update
     */
    __filterViews(viewsNameList = []) {
        return new Promise(resolve =&gt; {
            this.setState(
                {
                    views: this.state.views.filter(
                        view =&gt; viewsNameList.indexOf(view.props.name) !== -1
                    )
                },
                resolve
            );
        });
    }

    /**
     * Disables scene&apos;s GUI by provinding extra layer on top of everything else.
     * This layer can be customize by `cover` argument.
     * @param {object} cover React element to be placed in covering layer
     * @returns {Promise}  Will be resolved on succesful state update
     */
    disableGUI = (cover = null) =&gt; {
        return new Promise(resolve =&gt;
            this.setState(
                { GUIDisabled: true, GUIDisableCover: cover },
                resolve
            )
        );
    };

    /**
     * Disables layer covering scene and enable user interactions.
     * @returns {Promise} Will be resolved on succesful state update
     */
    enableGUI = () =&gt; {
        return new Promise(resolve =&gt;
            this.setState(
                { GUIDisabled: false, GUIDisableCover: null },
                resolve
            )
        );
    };

    /**
     * Get view index in views array
     * @param {string} viewName
     * @returns {integer}
     */
    getViewIndex = viewName =&gt;
        this.state.views.findIndex(view =&gt; view.props.name === viewName);

    /**
     * Private method for pushing new view config into this.state.views array
     * @param {object} config
     * @param {object} sceneProps
     * @returns {Promise}  Will be resolved on succesful state update
     */
    __pushView(config, sceneProps = {}) {
        const newviewdefinition = update(this.state.views, { $push: [config] });
        const stateChange = Object.assign(
            {
                views: newviewdefinition
            },
            Object.assign({}, config.sceneProps || {}),
            Object.assign({}, sceneProps)
        );

        return new Promise(resolve =&gt;
            this.setState(stateChange, () =&gt; resolve(config.props.name))
        );
    }

    /**
     * Pops out with animation currently active view from view&apos;s array
     * @param {object} viewProps props to modify the view just before popping
     * @param {object} sceneProps props to modify the scene while popping
     * @returns {Promise}  Will be resolved on succesful state update or rejected when no view to pop
     */
    popView = (viewProps = {}, sceneProps = {}) =&gt; {
        if (this.state.views.length &gt; 1) {
            const viewName = this.state.views[this.state.views.length - 2].props
                .name;

            return this.changeView(viewName, viewProps, sceneProps).then(() =&gt; {
                const newviewdefinition = update(this.state.views, {
                    $splice: [[this.state.views.length - 1, 1]]
                });

                delete this.refsCOMPViews[
                    this.state.views[this.state.views.length - 1].props.name
                ];

                return new Promise(resolve =&gt;
                    this.setState({ views: newviewdefinition }, () =&gt;
                        resolve(viewName)
                    )
                );
            });
        } else {
            return Promise.reject();
        }
    };

    /**
     * Check wheter object is valid view config and can be added to view&apos;s array
     * @param {object} object
     * @returns {bool}
     */
    isValidViewConfig(object) {
        return (
            typeof object === &quot;object&quot; &amp;&amp;
            &quot;type&quot; in object &amp;&amp;
            typeof object.props === &quot;object&quot; &amp;&amp;
            &quot;name&quot; in object.props
        );
    }

    /**
     * Crucial method of the scene component for manipalutaing views and scene properties and performing animations.
     * Can change active view with animation or just update view and scene properties.
     *
     * Change view by:
     * - string name kept in state views array which will lead to view change (with animation) or just update if currently active
     * - string name kept in `this.viewsConfig` which will lead to view push (with animation)
     * - new view config wich will lead to view change
     *
     * @param {string|object} view View name to change or view config to be added
     * @param {object} viewProps Extra props to be added to changing view
     * @param {object} sceneProps Extra props to manipulate this scene while changing view
     * @returns {Promise} Resolved on state succesful change and animation end. Or reject on failure.
     */
    changeView(view, viewProps = {}, sceneProps = {}) {
        return this.__changeView(view, viewProps, sceneProps).then(viewName =&gt; {
            return this.__performViewsAnimation(viewName);
        });
    }

    /**
     * Removes view from views array
     * @param {string} name
     */
    destroyView(name) {
        return new Promise((resolve, reject) =&gt; {
            const index = this.state.views.findIndex(
                view =&gt; view.props.name === name
            );

            if (index !== -1) {
                this.setState(
                    {
                        views: update(this.state.views, {
                            $splice: [[index, 1]]
                        })
                    },
                    resolve
                );
            } else {
                reject(`View with name: ${name} was not found in this scene.`);
            }
        });
    }

    /**
     * Make modification to scene&apos;s views by pushing new, updating current or changing between added views
     *
     * @param {string|object} view View name to change or view config to be added
     * @param {object} viewProps Extra props to be added to changing view
     * @param {object} sceneProps Extra props to manipulate this scene while changing view
     * @returns {Promise} Resolved on state succesful change and animation end. Or reject on failure.
     */
    __changeView(view, viewProps = {}, sceneProps = {}) {
        if (typeof view === &quot;string&quot;) {
            if (this.hasViewInState(view)) {
                //if already in state then update its props
                return new Promise(resolve =&gt; {
                    const viewIndex = this.getViewIndex(view);
                    const currentViewConfig = Object.assign(
                        { sceneProps: {} }, //for a default props which will be latter used
                        this.state.views[viewIndex]
                    );
                    const newViewConfig = update(currentViewConfig, {
                        props: {
                            $set: {
                                ...currentViewConfig.props,
                                ...viewProps
                            }
                        }
                    });

                    let stateChange = {
                        views: update(this.state.views, {
                            [viewIndex]: {
                                $set: newViewConfig
                            }
                        }),
                        ...currentViewConfig.sceneProps,
                        ...Object.assign({}, sceneProps)
                    };

                    this.setState(stateChange, () =&gt; resolve(view));
                });
            } else if (this.hasViewInConfig(view)) {
                //push fresh config
                return this.__pushView(
                    this.getFreshViewConfig(view, viewProps),
                    sceneProps
                );
            } else return Promise.reject();
        } else if (this.isValidViewConfig(view)) {
            //push allready prepared config
            return this.__pushView(
                Object.assign({}, view, {
                    props: { ...view.props, ...viewProps }
                }),
                sceneProps
            );
        } else {
            return Promise.reject();
        }
    }

    /**
     * Check if view&apos;s name is described by some config in `this.viewsConfig` object
     * @param {string} name
     * @returns {bool}
     */
    hasViewInConfig = name =&gt; name in this.viewsConfig;

    /**
     * Check if view recognize by name argument is present in state
     * @param {string} name
     * @returns {bool}
     */
    hasViewInState = name =&gt;
        this.state.views.findIndex(view =&gt; view.props.name === name) !== -1
            ? true
            : false;

    /**
     * Utility function to handle back button clicks.
     * Can be overwritten by class extending this wrapper.
     * By default it pops currently active view.
     * To use it, assign it&apos;s value to state like this:
     * this.state.handleBackButton = this.handleBackButton
     *
     * @returns {Promise} Resolved on state succesful change or reject on failure.
     */
    handleBackButton = (viewProps, sceneProps) =&gt; {
        if (this.state.views.length &gt; 1) {
            return this.popView(viewProps, sceneProps);
        }

        return Promise.reject();
    };

    /**
     * Disables scene&apos;s sidepanel by setting it prop enabled = false.
     * @returns {Promise} Resolved on state succesful change or reject on failure.
     */
    disableSidepanel = () =&gt; {
        if (this.state.sidepanel &amp;&amp; this.refCOMPSidepanel.current) {
            this.refCOMPSidepanel.current.disable();
            return new Promise(resolve =&gt;
                this.setState(
                    {
                        sidepanel: update(this.state.sidepanel, {
                            props: {
                                enabled: { $set: false }
                            }
                        })
                    },
                    resolve
                )
            );
        }

        return Promise.reject();
    };

    /**
     * Enables scene&apos;s sidepanel by setting it prop enabled = true.
     * @returns {Promise} Resolved on state succesful change or reject on failure.
     */

    enableSidepanel = () =&gt; {
        if (this.state.sidepanel &amp;&amp; this.refCOMPSidepanel.current) {
            this.refCOMPSidepanel.current.enable();
            return new Promise(resolve =&gt;
                this.setState(
                    {
                        sidepanel: update(this.state.sidepanel, {
                            props: {
                                enabled: { $set: true }
                            }
                        })
                    },
                    resolve
                )
            );
        }

        return Promise.reject();
    };

    /**
     * Shows sidepanel
     * @returns {Promise}
     */
    openSidepanel = () =&gt; {
        if (this.state.sidepanel &amp;&amp; this.refCOMPSidepanel.current) {
            return this.refCOMPSidepanel.current.show();
        }

        return Promise.reject();
    };

    /**
     * Hides sidepanel
     * @returns {Promise}
     */
    hideSidepanel = () =&gt; {
        if (this.state.sidepanel &amp;&amp; this.refCOMPSidepanel.current) {
            return this.refCOMPSidepanel.current.hide();
        }

        return Promise.reject();
    };

    /**
     * Add new mayer to this.state.mayers configurations array.
     * This will immediatelly open new mayer due to `componentDidMount` lifecycle implementation.
     *
     * @param {object} config Mayer config object.
     * @returns {Promise}
     */
    openMayer(config) {
        if (
            this.state.mayers.findIndex(item =&gt; item.name === config.name) !==
            -1
        ) {
            console.warn(
                &quot;[Airr] Scene allready has Mayer with this name: &quot; + config.name
            );
            return;
        }

        //if scene has sidepanel - disable it
        if (this.state.sidepanel &amp;&amp; this.state.sidepanel.props.enabled) {
            this.disableSidepanel();
        }

        //add special functionality
        const preparedConfig = this.__prepareMayerConfig(config);

        return this.__addMayer(preparedConfig);
    }

    /**
     * Close mayer by name
     *
     * @param {string} name Unique mayer name
     * @returns {Promise}
     */
    closeMayer(name) {
        let mayerConfigIndex = this.state.mayers.findIndex(
            item =&gt; item.name === name
        );

        if (
            mayerConfigIndex !== -1 &amp;&amp;
            (this.refsCOMPMayers[name] &amp;&amp; this.refsCOMPMayers[name].current)
        ) {
            this.refsCOMPMayers[name].current.animateOut(() =&gt; {
                //renew index because after animation
                //things might have changed
                mayerConfigIndex = this.state.mayers.findIndex(
                    item =&gt; item.name === name
                );

                //last check if stil present
                if (
                    mayerConfigIndex !== -1 &amp;&amp;
                    (this.refsCOMPMayers[name] &amp;&amp;
                        this.refsCOMPMayers[name].current)
                ) {
                    return this.__removeMayer(name).then(() =&gt; {
                        delete this.refsCOMPMayers[name];

                        if (this.state.sidepanel) {
                            let hasMayerLeft = false;
                            const children = [...this.refDOM.current.children];
                            children.forEach(item =&gt; {
                                if (item.classList.contains(&quot;airr-mayer&quot;)) {
                                    hasMayerLeft = true;
                                }
                            });

                            if (!hasMayerLeft) {
                                this.enableSidepanel();
                            }
                        }
                    });
                }
            });
        }
    }

    /**
     * If config has buttons that contains logical true `close` property,
     * this method will attach close mayer functionality to tap event on this button.
     *
     * @param {object} mayerConfig mayer config object
     * @returns {object}
     */
    __prepareMayerConfig(mayerConfig) {
        const config = Object.assign({}, mayerConfig);

        const ref = React.createRef();
        config.ref = ref;
        this.refsCOMPMayers[config.name] = ref;

        if (config.buttons &amp;&amp; config.buttons.length) {
            config.buttons.forEach(item =&gt; {
                if (item.close) {
                    if (item.handler) {
                        const oldHandler = item.handler;
                        item.handler = e =&gt; {
                            oldHandler(e);
                            this.closeMayer(config.name);
                        };
                    } else {
                        item.handler = e =&gt; {
                            this.closeMayer(config.name);
                        };
                    }
                }
            });
        }

        return config;
    }

    /**
     * Private utility for adding mayers
     * @param {objec} config
     * @returns {Promise}
     */
    __addMayer = config =&gt; {
        const newMayersDef = update(this.state.mayers, { $push: [config] });

        return new Promise(resolve =&gt;
            this.setState(
                {
                    mayers: newMayersDef
                },
                resolve
            )
        );
    };

    /**
     * Private utility for removing mayers
     * @param {string} name Mayer name
     * @returns {Promise}
     */

    __removeMayer = name =&gt; {
        const newMayersDef = this.state.mayers.filter(item =&gt; {
            return item.name !== name;
        });

        return new Promise(resolve =&gt;
            this.setState(
                {
                    mayers: newMayersDef
                },
                resolve
            )
        );
    };

    /**
     * Disables back button meaning it will not be visible in navbar anymore.
     * @returns {Promise}
     */
    disableBackButton = () =&gt; {
        return new Promise(resolve =&gt;
            this.setState({ backButton: false }, resolve)
        );
    };

    /**
     * Enables back button meaning it will be visible in navbar.
     * @returns {Promise}
     */
    enableBackButton = () =&gt; {
        return new Promise(resolve =&gt;
            this.setState({ backButton: true }, resolve)
        );
    };

    /**
     * Action dispatcher method. Will return a function ready to fire view change.
     * @param {string} name
     * @param {array} viewsNamesToStayList
     * @returns {function} Function that will resolve view change on invoke.
     */
    goToView = (name, viewsNamesToStayList = []) =&gt; {
        return (params = {}, sceneProps = {}) =&gt; {
            this.viewsNamesToStayList = viewsNamesToStayList;
            return this.changeView(name, params, sceneProps);
        };
    };

    componentDidMount() {
        if (
            this.state.navbar &amp;&amp;
            this.state.navbarHeight &amp;&amp;
            this.refDOMContainer.current
        ) {
            //subsctract navbar height from scene&apos;s container
            this.refDOMContainer.current.style.height =
                this.refDOMContainer.current.parentNode.clientHeight -
                this.state.navbarHeight +
                &quot;px&quot;;
        }

        /**
         * Call first active view life cycle method - viewAfterActivation
         */
        if (
            this.state.activeViewName &amp;&amp;
            this.refsCOMPViews[this.state.activeViewName] &amp;&amp;
            typeof this.refsCOMPViews[this.state.activeViewName].current
                .viewAfterActivation === &quot;function&quot;
        ) {
            this.refsCOMPViews[
                this.state.activeViewName
            ].current.viewAfterActivation();
        }
    }

    /**
     * Private utility function for preparing sidepanel configuration objects
     * @param {object} sidepanel
     * @returns {object}
     */
    __prepareSidepanel(sidepanel) {
        sidepanel.props.ref = this.refCOMPSidepanel;
        sidepanel.props.visibilityCallback = isShown =&gt; {
            this.setState({
                sidepanel: update(this.state.sidepanel, {
                    props: {
                        isShown: {
                            $set: isShown
                        }
                    }
                })
            });
        };

        if (typeof sidepanel.props.enabled === &quot;undefined&quot;) {
            sidepanel.props.enabled = true; //force explicit value, e.g needed when checking if panel is enabled in `openMayer` method
        }

        return Object.assign({}, sidepanel);
    }

    /**
     * Takes array of views and assign react specific properties (key and ref) to each view configuartion
     *
     * @param {array} views
     * @returns {array}
     */
    __prepareViews(views) {
        return views.map(item =&gt; {
            item.props.key = item.props.name;

            const ref = React.createRef();
            item.props.ref = ref;
            this.refsCOMPViews[item.props.name] = ref;

            return item;
        });
    }

    render() {
        const { views, sidepanel, className, ...stateRest } = this.state;

        return (
            &lt;AirrScene
                {...{
                    ...stateRest,
                    views: this.__prepareViews(views),
                    sidepanel: sidepanel &amp;&amp; this.__prepareSidepanel(sidepanel),
                    refDOM: this.refDOM,
                    refDOMContainer: this.refDOMContainer,
                    refDOMNavbar: this.refDOMNavbar,
                    refCOMPSidepanel: this.refCOMPSidepanel
                }}
                {...this.getViewProps()}
                {...{ className }}
            /&gt;
        );
    }

    /**
     * Describes if views animation is taking place
     */
    viewChangeInProgress = false;

    /**
     * Private utility function that changes views with animation
     *
     * @param {string} newViewName
     * @returns {Promise}
     */
    __performViewsAnimation(newViewName) {
        if (typeof newViewName === &quot;string&quot;) {
            this.viewChangeInProgress = true;

            return new Promise((resolve, reject) =&gt; {
                if (newViewName === this.state.activeViewName) {
                    console.warn(&quot;[Airr] This View is already active.&quot;);
                    this.viewChangeInProgress = false;
                    return resolve();
                }

                this.setState(
                    { GUIDisabled: true, mockTitle: newViewName },
                    () =&gt; {
                        if (this.getViewIndex(newViewName) !== -1) {
                            const oldViewName = this.state.activeViewName;
                            const newViewComp =
                                this.refsCOMPViews[newViewName] &amp;&amp;
                                this.refsCOMPViews[newViewName].current;
                            const oldViewComp =
                                this.refsCOMPViews[oldViewName] &amp;&amp;
                                this.refsCOMPViews[oldViewName].current;
                            const animEndCallback = () =&gt; {
                                this.viewChangeInProgress = false;

                                if (
                                    newViewComp &amp;&amp;
                                    typeof newViewComp.viewAfterActivation ===
                                        &quot;function&quot;
                                ) {
                                    newViewComp.viewAfterActivation();
                                }

                                if (
                                    oldViewComp &amp;&amp;
                                    typeof oldViewComp.viewAfterDeactivation ===
                                        &quot;function&quot;
                                ) {
                                    oldViewComp.viewAfterDeactivation();
                                }

                                if (
                                    typeof this.props
                                        .viewsAnimationEndCallback ===
                                    &quot;function&quot;
                                ) {
                                    this.props.viewsAnimationEndCallback();
                                }

                                resolve();
                            };

                            if (
                                newViewComp &amp;&amp;
                                typeof newViewComp.viewBeforeActivation ===
                                    &quot;function&quot;
                            ) {
                                newViewComp.viewBeforeActivation();
                            }

                            if (
                                oldViewComp &amp;&amp;
                                typeof oldViewComp.viewBeforeDeactivation ===
                                    &quot;function&quot;
                            ) {
                                oldViewComp.viewBeforeDeactivation();
                            }

                            if (this.state.animation) {
                                this.__doViewsAnimation(
                                    newViewName,
                                    oldViewName
                                ).then(() =&gt; {
                                    this.setState(
                                        {
                                            activeViewName: newViewName,
                                            GUIDisabled: false,
                                            mockTitle: false
                                        },
                                        animEndCallback
                                    );
                                });
                            } else {
                                this.setState(
                                    {
                                        activeViewName: newViewName,
                                        GUIDisabled: false,
                                        mockTitle: false
                                    },
                                    animEndCallback
                                );
                            }
                        } else {
                            this.viewChangeInProgress = false;
                            console.warn(
                                &quot;[Airr] View with name &quot; +
                                    newViewName +
                                    &quot; is not presence in this Scene.&quot;
                            );
                            reject();
                        }
                    }
                );
            });
        } else {
            console.warn(
                &quot;[Airr] You must specify view name property as string value&quot;
            );
            return Promise.reject();
        }
    }

    /**
     * Private utility function. This one actually makes css animations.
     *
     * @param {string} newViewName
     * @param {string} oldViewName
     * @returns {Promise}
     */
    __doViewsAnimation(newViewName, oldViewName) {
        return new Promise((resolve, reject) =&gt; {
            const newViewDOM =
                this.refsCOMPViews[newViewName] &amp;&amp;
                this.refsCOMPViews[newViewName].current &amp;&amp;
                this.refsCOMPViews[newViewName].current.refDOM &amp;&amp;
                this.refsCOMPViews[newViewName].current.refDOM.current;
            const oldViewIndex = this.getViewIndex(oldViewName);
            const newViewIndex = this.getViewIndex(newViewName);

            const direction = newViewIndex &gt; oldViewIndex ? 1 : -1;

            if (!newViewDOM) {
                throw new Error(&quot;new view DOM refference was not found&quot;);
            }

            if (this.state.navbar) {
                //perform navbar animations
                const titleNode = this.refDOMNavbar.current.querySelector(
                    &quot;.title&quot;
                );
                const mockTitle = this.refDOMNavbar.current.querySelector(
                    &quot;.mock-title&quot;
                );
                const mockTextSpan = mockTitle &amp;&amp; mockTitle.children[0];
                const mockTextSpanWidth = mockTextSpan
                    ? mockTextSpan.clientWidth
                    : 0;

                if (titleNode) {
                    AirrFX.doTransitionAnimation(
                        titleNode,
                        {
                            webkitTransform: `translate3d(${(titleNode.clientWidth /
                                2 +
                                mockTextSpanWidth / 2) *
                                direction +
                                &quot;px&quot;},0,0)`,
                            transform: `translate3d(${(titleNode.clientWidth /
                                2 +
                                mockTextSpanWidth / 2) *
                                direction +
                                &quot;px&quot;},0,0)`,
                            opacity: 0
                        },
                        [
                            `opacity ${this.state.animationTime}ms ease-out`,
                            `transform ${this.state.animationTime}ms ease-out`
                        ],
                        {
                            webkitTransform: `translate3d(0,0,0)`,
                            transform: `translate3d(0,0,0)`,
                            opacity: 1
                        },
                        null,
                        this.state.animationTime
                    );
                }

                if (mockTitle) {
                    AirrFX.doTransitionAnimation(
                        mockTitle,
                        {
                            webkitTransform: &quot;translate3d(0,0,0)&quot;,
                            transform: &quot;translate3d(0,0,0)&quot;,
                            opacity: 1
                        },
                        [
                            `opacity ${this.state.animationTime}ms ease-out`,
                            `transform ${this.state.animationTime}ms ease-out`
                        ],
                        {
                            webkitTransform: `translate3d(${mockTextSpanWidth *
                                direction *
                                -1 +
                                &quot;px&quot;},0,0)`,
                            transform: `translate3d(${mockTextSpanWidth *
                                direction *
                                -1 +
                                &quot;px&quot;},0,0)`,
                            opacity: 0
                        },
                        null,
                        this.state.animationTime
                    );
                }

                if (
                    this.state.backButton &amp;&amp;
                    !this.state.backButtonOnFirstView
                ) {
                    const backDOM = this.refDOMNavbar.current.querySelector(
                        &quot;.back&quot;
                    );

                    if (oldViewIndex === 0) {
                        //show back button with animation
                        AirrFX.doTransitionAnimation(
                            backDOM,
                            {
                                webkitTransform: &quot;translate3d(100%,0,0)&quot;,
                                transform: &quot;translate3d(100%,0,0)&quot;,
                                opacity: 0
                            },
                            [
                                `opacity ${
                                    this.state.animationTime
                                }ms ease-out`,
                                `transform ${
                                    this.state.animationTime
                                }ms ease-out`
                            ],
                            {
                                webkitTransform: &quot;translate3d(0,0,0)&quot;,
                                transform: &quot;translate3d(0,0,0)&quot;,
                                opacity: 1
                            },
                            () =&gt; backDOM.classList.remove(&quot;hidden&quot;),
                            this.state.animationTime
                        );
                    } else if (newViewIndex === 0) {
                        //hide backbutton with animation
                        AirrFX.doTransitionAnimation(
                            backDOM,
                            {
                                webkitTransform: &quot;translate3d(0,0,0)&quot;,
                                transform: &quot;translate3d(0,0,0)&quot;,
                                opacity: 1
                            },
                            [
                                `opacity ${
                                    this.state.animationTime
                                }ms ease-out`,
                                `transform ${
                                    this.state.animationTime
                                }ms ease-out`
                            ],
                            {
                                webkitTransform: &quot;translate3d(-100%,0,0)&quot;,
                                transform: &quot;translate3d(-100%,0,0)&quot;,
                                opacity: 0
                            },
                            null,
                            this.state.animationTime,
                            () =&gt; {
                                backDOM.style.webkitTransform = &quot;&quot;;
                                backDOM.style.transform = &quot;&quot;;
                                backDOM.style.opacity = &quot;&quot;;
                            }
                        );
                    }
                }
            }

            if (this.state.animation === &quot;slide&quot; &amp;&amp; oldViewName) {
                newViewDOM.style.display = &quot;block&quot;;
                let startProps = {};
                let endProps = {};

                if (direction === -1) {
                    startProps.webkitTransform =
                        &quot;translate3d(&quot; +
                        -1 * this.refDOM.current.clientWidth +
                        &quot;px,0,0)&quot;;
                    startProps.transform =
                        &quot;translate3d(&quot; +
                        -1 * this.refDOM.current.clientWidth +
                        &quot;px,0,0)&quot;;
                    endProps.webkitTransform = &quot;translate3d(0,0,0)&quot;;
                    endProps.transform = &quot;translate3d(0,0,0)&quot;;
                } else {
                    endProps.webkitTransform =
                        &quot;translate3d(&quot; +
                        -1 * this.refDOM.current.clientWidth +
                        &quot;px,0,0)&quot;;
                    endProps.transform =
                        &quot;translate3d(&quot; +
                        -1 * this.refDOM.current.clientWidth +
                        &quot;px,0,0)&quot;;
                }

                AirrFX.doTransitionAnimation(
                    this.refDOMContainer.current,
                    startProps,
                    [`transform ${this.state.animationTime}ms ease-out`],
                    endProps,
                    null,
                    this.state.animationTime,
                    () =&gt; {
                        newViewDOM.style.display = &quot;&quot;;
                        this.refDOMContainer.current.style.webkitTransform =
                            &quot;translate3d(0,0,0)&quot;;
                        this.refDOMContainer.current.style.transform =
                            &quot;translate3d(0,0,0)&quot;;
                        this.refDOMContainer.current.style.webkitTransition =
                            &quot;&quot;;
                        this.refDOMContainer.current.style.transition = &quot;&quot;;
                        this.refDOMContainer.current.style.transition = &quot;&quot;;
                        this.refDOMContainer.current.style.webkitBackfaceVisibility =
                            &quot;&quot;;
                        this.refDOMContainer.current.style.backfaceVisibility =
                            &quot;&quot;;

                        resolve();
                    }
                );
            } else if (this.state.animation === &quot;overlay&quot; &amp;&amp; oldViewName) {
                if (direction === 1) {
                    AirrFX.doTransitionAnimation(
                        newViewDOM,
                        {
                            webkitTransform: `translate3d(${this.refDOMContainer
                                .current.clientWidth + &quot;px&quot;},0,0)`,
                            transform: `translate3d(${this.refDOMContainer
                                .current.clientWidth + &quot;px&quot;},0,0)`,
                            opacity: 0,
                            display: &quot;block&quot;
                        },
                        [
                            `opacity ${this.state.animationTime}ms ease-out`,
                            `transform ${this.state.animationTime}ms ease-out`
                        ],
                        {
                            webkitTransform: `translate3d(0,0,0)`,
                            transform: `translate3d(0,0,0)`,
                            opacity: 1
                        },
                        () =&gt; (newViewDOM.style.zIndex = 102),
                        this.state.animationTime,
                        () =&gt; {
                            newViewDOM.style.zIndex = &quot;&quot;;
                            newViewDOM.style.display = &quot;&quot;;
                            newViewDOM.style.transform = &quot;&quot;;
                            newViewDOM.style.webkitTransform = &quot;&quot;;
                            newViewDOM.style.transition = &quot;&quot;;
                            newViewDOM.style.webkitTransition = &quot;&quot;;
                            newViewDOM.style.opacity = &quot;&quot;;

                            resolve();
                        }
                    );
                } else {
                    if (this.state.stackMode) {
                        const oldViewDOM = this.refsCOMPViews[oldViewName]
                            .current.refDOM.current;
                        newViewDOM.style.display = &quot;block&quot;;
                        newViewDOM.style.opacity = 1;

                        AirrFX.doTransitionAnimation(
                            oldViewDOM,
                            {
                                webkitTransform: `translate3d(0,0,0)`,
                                transform: `translate3d(0,0,0)`,
                                opacity: 1
                            },
                            [
                                `opacity ${
                                    this.state.animationTime
                                }ms ease-out`,
                                `transform ${
                                    this.state.animationTime
                                }ms ease-out`
                            ],
                            {
                                webkitTransform: `translate3d(0,${this
                                    .refDOMContainer.current.clientHeight /
                                    4 +
                                    &quot;px&quot;},0)`,
                                transform: `translate3d(0,${this.refDOMContainer
                                    .current.clientHeight /
                                    4 +
                                    &quot;px&quot;},0)`,
                                opacity: 0
                            },
                            null,
                            this.state.animationTime,
                            () =&gt; {
                                oldViewDOM.style.transition = &quot;&quot;;
                                oldViewDOM.style.webkitTransition = &quot;&quot;;
                                oldViewDOM.style.transform = &quot;&quot;;
                                oldViewDOM.style.webkitTransform = &quot;&quot;;
                                oldViewDOM.style.opacity = &quot;&quot;;

                                newViewDOM.style.display = &quot;&quot;;
                                newViewDOM.style.opacity = &quot;&quot;;

                                resolve();
                            }
                        );
                    } else {
                        newViewDOM.style.display = &quot;block&quot;;

                        AirrFX.doTransitionAnimation(
                            newViewDOM,
                            {
                                webkitTransform: `translate3d(${-1 *
                                    this.refDOMContainer.current.clientWidth +
                                    &quot;px&quot;},0,0)`,
                                transform: `translate3d(${-1 *
                                    this.refDOMContainer.current.clientWidth +
                                    &quot;px&quot;},0,0)`,
                                opacity: 0
                            },
                            [
                                `opacity ${
                                    this.state.animationTime
                                }ms ease-out`,
                                `transform ${
                                    this.state.animationTime
                                }ms ease-out`
                            ],
                            {
                                webkitTransform: `translate3d(0,0,0)`,
                                transform: `translate3d(0,0,0)`,
                                opacity: 1
                            },
                            () =&gt; (newViewDOM.style.zIndex = 102),
                            this.state.animationTime,
                            () =&gt; {
                                newViewDOM.style.display = &quot;&quot;;
                                newViewDOM.style.zIndex = &quot;&quot;;
                                newViewDOM.style.transform = &quot;&quot;;
                                newViewDOM.style.webkitTransform = &quot;&quot;;
                                newViewDOM.style.transition = &quot;&quot;;
                                newViewDOM.style.webkitTransition = &quot;&quot;;
                                newViewDOM.style.opacity = &quot;&quot;;

                                resolve();
                            }
                        );
                    }
                }
            } else if (this.state.animation === &quot;fade&quot; || !oldViewName) {
                AirrFX.doTransitionAnimation(
                    newViewDOM,
                    {
                        opacity: 0
                    },
                    [`opacity ${this.state.animationTime}ms ease-out`],
                    {
                        opacity: 1
                    },
                    () =&gt; (newViewDOM.style.zIndex = 102),
                    this.state.animationTime,
                    () =&gt; {
                        newViewDOM.style.zIndex = &quot;&quot;;
                        resolve();
                    }
                );
            }
        });
    }
}

AirrSceneWrapper.defaultProps = {
    name: &quot;&quot;,
    activeViewName: null,
    GUIDisabled: false,
    GUIDisableCover: null,
    animation: &quot;slide&quot;,
    animationTime: 300,
    navbar: false,
    navbarHeight: 48,
    navbarMenu: null,
    navbarClass: &quot;&quot;,
    backButton: false,
    backButtonOnFirstView: false,
    handleBackButton: null,
    handleBackBehaviourOnFirstView: null,
    viewsAnimationEndCallback: null,
    active: false,
    sidepanel: null,
    views: [],
    mayers: [],
    title: &quot;&quot;,
    className: &quot;&quot;,

    stackMode: false
};
AirrSceneWrapper.propTypes = {
    /**
     * The name of the scene. Must be unique among others views in parent scene. Will be used as identification string
     */
    name: PropTypes.string.isRequired,
    /**
     * Name of the active view.
     */
    activeViewName: PropTypes.string,
    /**
     * Boolean telling if GUI should be disabled meaning no user actions, events are allowed.
     * GUI is disabled via absolute positioned, not visible div that has the biggest z-Index
     */
    GUIDisabled: PropTypes.bool,
    /**
     * React element to be placed in GUI disabling div
     */
    GUIDisableCover: PropTypes.object,
    /**
     * Type of animation to perform when switching views
     */
    animation: PropTypes.oneOf([&quot;slide&quot;, &quot;overlay&quot;, &quot;fade&quot;, false]),
    /**
     * Time of views changing animatio
     */
    animationTime: PropTypes.number,
    /**
     * Specify if navbar is present (1,true) or not (0,false). Or maybe hidden (-1)
     */
    navbar: PropTypes.oneOf([-1, 0, false, 1, true]),
    /**
     * Height of the navbar in pixels
     */
    navbarHeight: PropTypes.number,
    /**
     * Navbar menu is placed on the right most side. Might contain &quot;toggleSidepanel&quot; button or any custom buttons list.
     */
    navbarMenu: function(props, propName, componentName) {
        if (props[propName]) {
            if (typeof props[propName] === &quot;string&quot;) {
                if (!/toggleSidepanel/.test(props[propName])) {
                    return new Error(
                        &quot;Invalid prop `&quot; +
                            propName +
                            &quot;` supplied to&quot; +
                            &quot; `&quot; +
                            componentName +
                            &quot;`. Value must be `toggleSidepanel` string or array of React elements.&quot;
                    );
                } else {
                    return null;
                }
            }

            if (!Array.isArray(props[propName])) {
                return new Error(
                    &quot;Invalid prop `&quot; +
                        propName +
                        &quot;` supplied to&quot; +
                        &quot; `&quot; +
                        componentName +
                        &quot;`. Value must be `toggleSidepanel` string or array of React elements.&quot;
                );
            }
        }
    },
    /**
     * Extra, space separated, navbar&apos;s class names list
     */
    navbarClass: PropTypes.string,
    /**
     * Boolean specifing if navbar renders BackButton. Placed by default on the left side of navbar.
     */
    backButton: PropTypes.bool,
    /**
     * Do you need to still show backButton even if scene is rendering first view from stack?
     */
    backButtonOnFirstView: PropTypes.bool,
    /**
     * Function that will handle back button click events
     */
    handleBackButton: PropTypes.func,
    /**
     * Function that will handle back button clicks events on when first view in stack is active
     */
    handleBackBehaviourOnFirstView: PropTypes.func,
    /**
     * Callback that will be invoked when views animation finishes
     */
    viewsAnimationEndCallback: PropTypes.func,
    /**
     * Is this view active in parent scene
     */
    active: PropTypes.bool,
    /**
     * Sidepanels declaration. Must contain two properties: `type` and `props`
     **/
    sidepanel: PropTypes.shape({
        /**
         * Refference to class or function that will render AirrSidepanel. Might be AirrSidepanel itself.
         */
        type: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
            .isRequired,
        /**
         * Special properties of AirrSidepanel class. Go to class declaration for further properties documenation.
         */
        props: PropTypes.shape({
            /**
             * Side to which sidepanel will be attached
             */
            side: PropTypes.oneOf([&quot;left&quot;, &quot;right&quot;, &quot;top&quot;, &quot;bottom&quot;]),
            /**
             * Bool determining if sidepanel is shown or not
             */
            isShown: PropTypes.bool,
            /**
             * Bool determining if sidepanel is enabled, another words, if its can be drag out
             */
            enabled: PropTypes.bool,
            /**
             * Number between 0 and 1 determining how much size of whole screen sidepanel will take
             */
            sizeFactor: PropTypes.number,
            /**
             * Parent scene width dimension. Passed by scene itself.
             */
            sceneWidth: PropTypes.number.isRequired,
            /**
             * Parent scene height dimension. Passed by scene itself.
             */
            sceneHeight: PropTypes.number.isRequired,
            /**
             * Do you want to animate sidepanel showing in/out
             */
            animateShown: PropTypes.bool,
            /**
             * Callback called when sidepanel changes its visibility during touch events. Passed by scene itself.
             */
            visibilityCallback: PropTypes.func,
            /**
             * Animation time in miliseconds
             */
            animationTime: PropTypes.number,
            /**
             * Opacity between 0 and 1
             */
            bgLayerOpacity: PropTypes.number
        })
    }),
    /**
     * Array of `views`. Every view object declaration must contain two properties: `type` and `props`.
     */
    views: PropTypes.arrayOf(
        PropTypes.shape({
            /**
             * Refference to class or function that will render AirrView. The most common and adviced approach is to use AirrViewWrapper.
             */
            type: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
                .isRequired,
            /**
             * Special properties of AirrView class. Go to class declaration for further properties documenation.
             */
            props: PropTypes.shape({
                /**
                 * The name of the view. Must be unique among others views in scene. Will be used as identification string
                 */
                name: PropTypes.string.isRequired,
                /**
                 * Titlebar name. if parent scene navbar is enabled, this title will be showed there
                 */
                title: PropTypes.string,
                /**
                 * Determine if this view is active. Set by parent scene.
                 */

                active: PropTypes.bool,
                /**
                 * Refference to view&apos;s root DOM element.
                 */
                refDOM: PropTypes.object,
                /**
                 * Extra classes to use. Space separetad string list.
                 */
                className: PropTypes.string,
                /**
                 * Extra styles to use upon root DOM element of view.
                 */
                style: PropTypes.object
            })
        })
    ),
    /**
     * Array of `mayers` objects that will be render into this Scene. Must contain special AirrMayer class properties.
     * To check the possible values of properties go to AirrMayer declaration.
     */
    mayers: PropTypes.arrayOf(
        PropTypes.shape({
            /**
             * The name of the mayer. Must be unique among others mayers in scene. Will be used as identification.
             */
            name: PropTypes.string.isRequired,
            /**
             * Extra styles to apply on Mayer&apos;s DOM element
             */
            style: PropTypes.object,
            /**
             * Parent scene height
             */
            avaibleHeight: PropTypes.number.isRequired,
            /**
             * Side from which mayer content box will enter
             */
            appearFrom: PropTypes.oneOf([&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;]),
            /**
             * Side to which mayer content box will leave
             */
            leaveTo: PropTypes.oneOf([&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;]),
            /**
             * Content of mayer
             */

            content: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
            /**
             * Array with buttons configuration
             */
            buttons: PropTypes.arrayOf(
                PropTypes.shape({
                    /**
                     * Extra class names to use upon button
                     */
                    className: PropTypes.string,
                    /**
                     * Extra attributes to apply on HTML element
                     */
                    attrs: PropTypes.object,
                    /**
                     * Additional inline styles
                     */
                    style: PropTypes.object,
                    /**
                     * OnClick function handler
                     */
                    handler: PropTypes.func,
                    /**
                     * Content to render inside Mayer. Might be string or ReactElement.
                     */
                    content: PropTypes.oneOfType([
                        PropTypes.string,
                        PropTypes.object
                    ])
                })
            ),
            /**
             * Time in miliseconds of mayer&apos;s appear/disappear animation
             */
            animationTime: PropTypes.number
        })
    ),
    /**
     * Title that will be use in parent Scene navbar title section
     */
    title: PropTypes.string,
    /**
     * Extra, space separated classes names to use upon first div element.
     */
    className: PropTypes.string,
    /**
     * This propety changes behaviour of views animation when overlay animation is set
     */
    stackMode: PropTypes.bool
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
