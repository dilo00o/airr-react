<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/AirrSidepanel.js | airr-react</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Reusable React components for building Single Page Apps."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="airr-react"><meta property="twitter:description" content="Reusable React components for building Single Page Apps."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/rafal-r/airr-react"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrMayer.js~AirrMayer.html">AirrMayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrScene.js~AirrScene.html">AirrScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrSceneWrapper.js~AirrSceneWrapper.html">AirrSceneWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrSidepanel.js~AirrSidepanel.html">AirrSidepanel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrView.js~AirrView.html">AirrView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/AirrViewWrapper.js~AirrViewWrapper.html">AirrViewWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-AirrFX">AirrFX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Helpers">Helpers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-isMobileDevice">isMobileDevice</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-supportPassive">supportPassive</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/AirrSidepanel.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import React, { Component } from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;
import { isMobileDevice, supportPassive } from &quot;./eventHelpers&quot;;

export default class AirrSidepanel extends Component {
    size;
    sceneSize;
    currentVal;
    hiddenVal;
    shownVal;
    transformScheme;
    axis;
    lastSide;
    lastSizeFactor;

    refDOMDragCtn = React.createRef();
    refDOMBgLayer = React.createRef();
    refDOM = React.createRef();
    sceneDOM;

    lastTouch;

    // state = {
    //     side: this.props.side,
    //     isShown: this.props.isShown,
    //     sizeFactor: this.props.sizeFactor,
    //     sceneWidth: this.props.sceneWidth,
    //     sceneHeight: this.props.sceneHeight
    // };

    startEvent = isMobileDevice ? &quot;touchstart&quot; : &quot;mousedown&quot;;
    moveEvent = isMobileDevice ? &quot;touchmove&quot; : &quot;mousemove&quot;;
    endEvent = isMobileDevice ? &quot;touchend&quot; : &quot;mouseup&quot;;

    enable() {
        this.sceneDOM.removeEventListener(
            this.startEvent,
            this.handleTouchStart
        );
        this.sceneDOM.addEventListener(
            this.startEvent,
            this.handleTouchStart,
            supportPassive
        );
    }

    disable() {
        this.sceneDOM.removeEventListener(
            this.startEvent,
            this.handleTouchStart
        );
    }

    componentDidMount() {
        this.sceneDOM = this.refDOM.current.parentNode;

        if (this.props.enabled) {
            this.enable();
        }
    }

    __bubbleChildTillParent(child, parent, tillElements) {
        if (child.parentNode === parent) {
            return true;
        } else {
            if (
                !child.parentNode ||
                tillElements.indexOf(child.parentNode) !== -1
            ) {
                return false;
            } else {
                return this.__bubbleChildTillParent(
                    child.parentNode,
                    parent,
                    tillElements
                );
            }
        }
    }

    getPosition = (e, axis) =&gt; {
        return &quot;changedTouches&quot; in e
            ? e.changedTouches[0][&quot;client&quot; + axis]
            : e[&quot;client&quot; + axis];
    };

    getLastPosition = e =&gt; {
        return &quot;changedTouches&quot; in e
            ? e.changedTouches[0]
            : { clientX: e.clientX, clientY: e.clientY };
    };

    getEventX = e =&gt; {
        return &quot;changedTouches&quot; in e ? e.changedTouches[0].clientX : e.clientX;
    };

    getEventY = e =&gt; {
        return &quot;changedTouches&quot; in e ? e.changedTouches[0].clientY : e.clientY;
    };

    handleTouchStart = e =&gt; {
        const pos = this.getPosition(e, this.axis);
        let dragCtnOnTouchPath = false;

        if (e.path) {
            for (let i = 0; i &lt; e.path.length; i++) {
                if (e.path[i] === this.refDOMDragCtn.current) {
                    dragCtnOnTouchPath = true;
                }
            }
        } else {
            if (
                e.target === this.refDOMDragCtn.current ||
                this.__bubbleChildTillParent(
                    e.target,
                    this.refDOMDragCtn.current,
                    [this.refDOMDragCtn.current.parentNode, document.body]
                )
            ) {
                dragCtnOnTouchPath = true;
            }
        }

        if (
            !dragCtnOnTouchPath &amp;&amp;
            (([&quot;left&quot;, &quot;top&quot;].indexOf(this.props.side) !== -1 &amp;&amp; pos &lt; 20) ||
                ([&quot;right&quot;, &quot;bottom&quot;].indexOf(this.props.side) !== -1 &amp;&amp;
                    pos &gt; this.hiddenVal - 20))
        ) {
            //corner touch, show moves

            this.refDOM.current.style.display = &quot;block&quot;;
            this.sceneDOM.addEventListener(
                this.moveEvent,
                this.handleShowTouchMove,
                supportPassive
            );
            this.sceneDOM.addEventListener(
                this.endEvent,
                this.handleTouchEnd,
                false
            );

            // this.triggerCustom(&quot;showTouchStart&quot;);

            const showmoveend = () =&gt; {
                this.sceneDOM.removeEventListener(this.endEvent, showmoveend); //remove self to act like once listener
                this.sceneDOM.removeEventListener(
                    this.moveEvent,
                    this.handleShowTouchMove
                );
                // this.triggerCustom(&quot;showTouchEnd&quot;);
            };

            this.sceneDOM.addEventListener(this.endEvent, showmoveend, false);
        } else if (this.currentVal === this.shownVal) {
            //fully visible, hide moves
            this.sceneDOM.addEventListener(
                this.moveEvent,
                this.handleHideTouchMove,
                supportPassive
            );
            this.sceneDOM.addEventListener(
                this.endEvent,
                this.handleTouchEnd,
                false
            );

            // this.triggerCustom(&quot;hideTouchStart&quot;);

            const hidemoveend = () =&gt; {
                this.sceneDOM.removeEventListener(this.endEvent, hidemoveend);
                this.sceneDOM.removeEventListener(
                    this.moveEvent,
                    this.handleHideTouchMove
                );
                // this.triggerCustom(&quot;hideTouchEnd&quot;);
            };

            this.sceneDOM.addEventListener(this.endEvent, hidemoveend, false);
        }

        if (e.target === this.refDOMBgLayer.current) {
            //tap to hide
            if (
                ([&quot;left&quot;, &quot;top&quot;].indexOf(this.props.side) !== -1 &amp;&amp;
                    this.currentVal === 0) ||
                ([&quot;right&quot;, &quot;bottom&quot;].indexOf(this.props.side) !== -1 &amp;&amp;
                    this.currentVal)
            ) {
                const hidedragctn = e =&gt; {
                    this.sceneDOM.removeEventListener(
                        this.endEvent,
                        hidedragctn
                    );
                    if (Math.abs(pos - this.getPosition(e, this.axis)) &lt;= 2.5) {
                        this.hide();
                    }
                };

                this.sceneDOM.addEventListener(
                    this.endEvent,
                    hidedragctn,
                    false
                );
            }
        }

        this.lastTouch = this.getLastPosition(e);
    };

    handleShowTouchMove = e =&gt; {
        const pos = this.getPosition(e, this.axis);
        let newVal, progress;

        if ([&quot;left&quot;, &quot;top&quot;].indexOf(this.props.side) !== -1) {
            if (pos &lt;= -1 * this.hiddenVal) {
                newVal = this.hiddenVal + pos;
            } else {
                newVal = this.shownVal;
            }
            progress = pos / this.size;
        } else {
            if (this.hiddenVal - pos &lt;= this.size) {
                newVal = pos;
            } else {
                newVal = this.shownVal;
            }
            progress = (this.sceneSize - pos) / this.size;
        }

        if (newVal !== this.currentVal) {
            this.currentVal = newVal;
            progress = parseFloat(progress);
            progress = progress &gt; 1 ? 1 : progress &lt; 0 ? 0 : progress;

            this.refDOMBgLayer.current.style.opacity =
                progress * this.props.bgLayerOpacity;

            this.refDOMDragCtn.current.style.webkitTransform = this.transformScheme.replace(
                &quot;%v&quot;,
                this.currentVal
            );
            this.refDOMDragCtn.current.style.transform = this.transformScheme.replace(
                &quot;%v&quot;,
                this.currentVal
            );
        }

        this.lastTouch = this.getLastPosition(e);

        if (!supportPassive) {
            e.preventDefault();
        }
    };

    handleHideTouchMove = e =&gt; {
        let progress, newVal, change, moveAxis;

        if (this.lastTouch) {
            if (
                Math.abs(this.lastTouch.clientX - this.getEventX(e)) &gt;=
                Math.abs(this.lastTouch.clientY - this.getEventY(e))
            ) {
                if (this.getEventX(e) - this.lastTouch.clientX &lt;= 0) {
                    // move = &apos;left&apos;;
                    moveAxis = &quot;X&quot;;
                } else {
                    // move = &apos;right&apos;;
                    moveAxis = &quot;X&quot;;
                }
            } else {
                if (this.getEventY(e) - this.lastTouch.clientY &lt;= 0) {
                    // move = &apos;top&apos;;
                    moveAxis = &quot;Y&quot;;
                } else {
                    // move = &apos;bottom&apos;;
                    moveAxis = &quot;Y&quot;;
                }
            }
        }

        if (
            moveAxis === this.axis &amp;&amp;
            (([&quot;left&quot;, &quot;top&quot;].indexOf(this.props.side) !== -1 &amp;&amp;
                this.getPosition(e, moveAxis) &lt; this.size) ||
                ([&quot;right&quot;, &quot;bottom&quot;].indexOf(this.props.side) !== -1 &amp;&amp;
                    this.getPosition(e, moveAxis) &gt; this.hiddenVal - this.size))
        ) {
            change =
                this.getPosition(e, this.axis) -
                this.lastTouch[&quot;client&quot; + this.axis];
            newVal = this.currentVal + change;

            if (this.props.side === &quot;left&quot; || this.props.side === &quot;top&quot;) {
                if (newVal &lt; this.hiddenVal) {
                    newVal = this.hiddenVal;
                } else if (newVal &gt; this.shownVal) {
                    newVal = this.shownVal;
                }

                progress = 1 - Math.abs(newVal / this.size);
            } else {
                if (newVal &gt; this.hiddenVal) {
                    newVal = this.hiddenVal;
                } else if (newVal &lt; this.shownVal) {
                    newVal = this.shownVal;
                }

                progress = (this.sceneSize - newVal) / this.size;
            }

            if (newVal !== this.currentVal) {
                this.currentVal = newVal;
                progress = parseFloat(progress);
                progress = progress &gt; 1 ? 1 : progress &lt; 0 ? 0 : progress;

                this.refDOMBgLayer.current.style.opacity =
                    progress * this.props.bgLayerOpacity;

                this.refDOMDragCtn.current.style.webkitTransform = this.transformScheme.replace(
                    &quot;%v&quot;,
                    this.currentVal
                );
                this.refDOMDragCtn.current.style.transform = this.transformScheme.replace(
                    &quot;%v&quot;,
                    this.currentVal
                );
            }
        }

        this.lastTouch = this.getLastPosition(e);
        if (!supportPassive) {
            e.preventDefault();
        }
    };

    handleTouchEnd = e =&gt; {
        let val = null;

        if (!this.animating) {
            if (
                this.currentVal !== this.shownVal &amp;&amp;
                this.currentVal !== this.hiddenVal
            ) {
                if ([&quot;left&quot;, &quot;top&quot;].indexOf(this.props.side) !== -1) {
                    if (this.currentVal &gt;= this.hiddenVal / 2) {
                        val = this.shownVal;
                    } else {
                        val = this.hiddenVal;
                    }
                } else {
                    if (this.currentVal &lt; this.hiddenVal - this.size / 2) {
                        val = this.shownVal;
                    } else {
                        val = this.hiddenVal;
                    }
                }
            } else if (this.currentVal === this.hiddenVal) {
                this.refDOM.current.style.display = &quot;none&quot;;
            }

            if (val !== null) {
                this.translateTo(val);
            } else {
                if (this.props.isShown !== this.isShown()) {
                    this.props.visibilityCallback(this.props.isShown);
                }
            }
        }

        this.sceneDOM.removeEventListener(this.endEvent, this.handleTouchEnd);
    };

    hide = () =&gt; {
        return this.translateTo(this.hiddenVal);
    };

    show = () =&gt; {
        return this.translateTo(this.shownVal);
    };

    isShown = () =&gt; {
        return this.refDOM.current.offsetParent !== null;
    };

    translateTo = finishVal =&gt; {
        return new Promise(resolve =&gt; {
            this.animating = true;

            this.refDOMBgLayer.current.style.webkitTransition = `opacity ${
                this.props.animationTime
            }ms ease-in`;
            this.refDOMBgLayer.current.style.transition = `opacity ${
                this.props.animationTime
            }ms ease-in`;
            // eslint-disable-next-line
            this.refDOMBgLayer.current.offsetHeight;

            if (finishVal === this.shownVal) {
                if (!this.isShown()) {
                    this.refDOM.current.style.display = &quot;block&quot;;
                }

                this.refDOMBgLayer.current.style.opacity = this.props.bgLayerOpacity;
            } else if (finishVal === this.hiddenVal) {
                this.refDOMBgLayer.current.style.opacity = 0;
            }
            // eslint-disable-next-line
            this.refDOM.current.offsetHeight;
            this.refDOM.current.style.webkitTransition = &quot;initial&quot;;
            this.refDOM.current.style.transition = &quot;initial&quot;;

            this.refDOMDragCtn.current.style.webkitTransition = `-webkit-transform ${
                this.props.animationTime
            }ms ease-out`;
            this.refDOMDragCtn.current.style.webkitTransition = `transform ${
                this.props.animationTime
            }ms ease-out`;
            this.refDOMDragCtn.current.style.transition = `transform ${
                this.props.animationTime
            }ms ease-out`;

            // eslint-disable-next-line
            this.refDOMDragCtn.current.offsetHeight;
            this.refDOMDragCtn.current.style.webkitTransform = this.transformScheme.replace(
                &quot;%v&quot;,
                finishVal
            );
            this.refDOMDragCtn.current.style.transform = this.transformScheme.replace(
                &quot;%v&quot;,
                finishVal
            );

            // eslint-disable-next-line
            this.refDOMDragCtn.current.offsetHeight;

            this.refDOMDragCtn.current.style.webkitTransition = &quot;initial&quot;;
            this.refDOMDragCtn.current.style.transition = &quot;initial&quot;;

            setTimeout(() =&gt; {
                this.refDOMBgLayer.current.style.webkitTransition = &quot;initial&quot;;
                this.refDOMBgLayer.current.style.transition = &quot;initial&quot;;

                this.currentVal = finishVal;

                if (finishVal === this.hiddenVal) {
                    this.refDOM.current.style.display = &quot;none&quot;;
                }

                this.animating = false;

                if (this.props.isShown !== this.isShown()) {
                    this.props.visibilityCallback(this.isShown());
                }

                resolve(this.isShown());
            }, this.props.animationTime + 5);
        });
    };

    updateSideProps(side, sizeFactor) {
        if (side === &quot;left&quot; || side === &quot;right&quot;) {
            this.size = this.props.sceneWidth * sizeFactor;
            this.sceneSize = this.props.sceneWidth;
            this.hiddenVal =
                side === &quot;left&quot; ? -1 * this.size : this.props.sceneWidth;
            this.transformScheme = &quot;translate3d(%vpx,0,0)&quot;;
            this.axis = &quot;X&quot;;
        } else {
            //top,bottom
            this.size = this.props.sceneHeight * sizeFactor;
            this.sceneSize = this.props.sceneHeight;
            this.hiddenVal =
                side === &quot;top&quot; ? -1 * this.size : this.props.sceneHeight;
            this.transformScheme = &quot;translate3d(0,%vpx,0)&quot;;
            this.axis = &quot;Y&quot;;
        }

        if (side === &quot;top&quot; || side === &quot;left&quot;) {
            this.shownVal = 0;
        } else {
            this.shownVal = this.sceneSize - this.size;
        }

        if (this.props.isShown) {
            this.currentVal = this.shownVal;
        } else {
            this.currentVal = this.hiddenVal;
        }

        this.lastSide = side;
        this.lastSizeFactor = sizeFactor;
    }

    componentDidUpdate(prevProps) {
        if (prevProps.enabled !== this.props.enabled) {
            return this[this.props.enabled ? &quot;enable&quot; : &quot;disable&quot;]();
        }
    }

    render() {
        const className =
            &quot;airr-sidepanel &quot; + this.props.side + &quot; &quot; + (this.props.enabled ? &quot;enabled&quot; : &quot;disabled&quot;);            
        const dragCtnStyle = {};
        let sidepanelStyle;
        let bgLayerStyle;

        if (
            this.props.side !== this.lastSide ||
            this.props.sizeFactor !== this.lastSizeFactor
        ) {
            this.updateSideProps(this.props.side, this.props.sizeFactor);
        }

        if (this.props.side === &quot;left&quot; || this.props.side === &quot;right&quot;) {
            dragCtnStyle.width = this.size + &quot;px&quot;;
            dragCtnStyle.height = &quot;100%&quot;;
        } else {
            //top,bottom
            dragCtnStyle.height = this.size + &quot;px&quot;;
            dragCtnStyle.width = &quot;100%&quot;;
        }

        if (this.props.isShown) {
            dragCtnStyle.WebkitTransform = this.transformScheme.replace(
                &quot;%v&quot;,
                this.shownVal
            );
            dragCtnStyle.transform = this.transformScheme.replace(
                &quot;%v&quot;,
                this.shownVal
            );
            sidepanelStyle = { display: &quot;block&quot; };
            bgLayerStyle = { opacity: this.props.bgLayerOpacity };
        } else {
            dragCtnStyle.WebkitTransform = this.transformScheme.replace(
                &quot;%v&quot;,
                this.hiddenVal
            );
            dragCtnStyle.transform = this.transformScheme.replace(
                &quot;%v&quot;,
                this.hiddenVal
            );
            sidepanelStyle = { display: &quot;none&quot; };
            bgLayerStyle = { opacity: 0 };
        }

        const children =
            typeof this.props.children === &quot;function&quot;
                ? this.props.children()
                : this.props.children;

        return (
            &lt;div className={className} ref={this.refDOM} style={sidepanelStyle}&gt;
                &lt;div ref={this.refDOMBgLayer} style={bgLayerStyle} /&gt;
                &lt;div ref={this.refDOMDragCtn} style={dragCtnStyle}&gt;
                    {children}
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}
AirrSidepanel.propTypes = {
    /**
     * Side to which sidepanel will be attached
     */
    side: PropTypes.oneOf([&quot;left&quot;, &quot;right&quot;, &quot;top&quot;, &quot;bottom&quot;]),
    /**
     * Bool determining if sidepanel is shown or not
     */
    isShown: PropTypes.bool,
    /**
     * Bool determining if sidepanel is enabled, another words, if its can be drag out
     */
    enabled: PropTypes.bool,
    /**
     * Number between 0 and 1 determining how much size of whole screen sidepanel will take
     */
    sizeFactor: PropTypes.number,
    /**
     * Parent scene width dimension. Set by parent scene. Do not overwrite!.
     */
    sceneWidth: PropTypes.number.isRequired,
    /**
     * Parent scene height dimension. Set by parent scene. Do not overwrite!.
     */
    sceneHeight: PropTypes.number.isRequired,
    /**
     * Do you want to animate sidepanel showing in/out
     */
    animateShown: PropTypes.bool,
    /**
     * Callback called when sidepanel changes its visibility during touch events. Set by parent scene. Do not overwrite!.
     */
    visibilityCallback: PropTypes.func,
    /**
     * Animation time in miliseconds
     */
    animationTime: PropTypes.number,
    /**
     * Opacity between 0 and 1
     */
    bgLayerOpacity: PropTypes.number
};
AirrSidepanel.defaultProps = {
    side: &quot;left&quot;,
    isShown: false,
    enabled: false,
    sizeFactor: 2 / 3,
    sceneWidth: null,
    sceneHeight: null,
    animateShown: true,
    visibilityCallback: function(isShown) {},
    animationTime: 200,
    bgLayerOpacity: 0.7
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
